<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="TCMECC Peripheral Library (TCMHECC)" />
<meta name="DC.relation" scheme="URI" content="GUID-1CE8F33B-F9EF-4806-9B9A-83D4F0D0F22C.html" />
<meta name="DC.relation" scheme="URI" content="GUID-CEA1DA29-BE84-494A-AA97-C861E20A5956.html" />
<meta name="DC.relation" scheme="URI" content="GUID-854A2B4A-D86B-46F7-B278-2D5A4F4F93D7.html" />
<meta name="DC.relation" scheme="URI" content="GUID-E616A811-31C2-4FAB-A01E-006809BB6755.html" />
<meta name="DC.relation" scheme="URI" content="GUID-E9A1537F-6ED6-4929-81DA-B31CF3D39050.html" />
<meta name="DC.relation" scheme="URI" content="GUID-A25021AC-4AB9-46F3-9367-2D395A6A5130.html" />
<meta name="DC.relation" scheme="URI" content="GUID-80E0015F-EE1D-4803-9562-B78D7BEF870C.html" />
<meta name="DC.relation" scheme="URI" content="GUID-9EC2F29D-DF15-4781-A419-29A17C8F686E.html" />
<meta name="DC.relation" scheme="URI" content="GUID-34C62344-B8CC-48D7-A919-C662653B9D7E.html" />
<meta name="DC.relation" scheme="URI" content="GUID-07D91ADA-A242-428A-B4E2-C73021377345.html" />
<meta name="DC.relation" scheme="URI" content="GUID-7780D62B-24BA-411E-B999-29A97DF1B558.html" />
<meta name="DC.relation" scheme="URI" content="GUID-3480A3F6-7BD4-4E62-BBA1-D49774C93DFC.html" />
<meta name="DC.relation" scheme="URI" content="GUID-FEA47424-3F90-49A3-9B31-C6D5E0905078.html" />
<meta name="DC.relation" scheme="URI" content="GUID-A07AEC91-1DBF-46B6-B253-A063C5BC86C2.html" />
<meta name="DC.relation" scheme="URI" content="GUID-B82875FD-AFB6-478F-BF52-C76B796BEC5B.html" />
<meta name="DC.relation" scheme="URI" content="GUID-4F9448B3-1CC9-4E5B-8AB2-D9C3BB1A6460.html" />
<meta name="DC.relation" scheme="URI" content="GUID-99905C10-3C9C-41F4-8691-6018AF48AC64.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="tcmecc-peripheral-library-tcmhecc" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<title>TCMECC Peripheral Library (TCMHECC)</title>
<meta name="Microsoft.Help.Id" content="GUID-1496A2CC-C97C-4626-8C96-AF36CD92FAF6-tcmecc-peripheral-library-tcmhecc" />
<meta name="Microsoft.Help.TocParent" content="GUID-1496A2CC-C97C-4626-8C96-AF36CD92FAF6" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Aerospace Library Reference A 01/2022" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
         
         function copyContent(content, button) {
         
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                     button.textContent = "Copy";
                     button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
               console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
         }
         
         function cpy(id, button) {
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            
            copyContent(content, button);
         }
         
         document.addEventListener("DOMContentLoaded", function(event) {
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.style.position = "relative";
               var copy = document.createElement("button");
               copy.textContent = "Copy";
               copy.setAttribute("class", "copy-code");
               
               var content = elem.textContent;
               
               copy.addEventListener("click", function(){
                  copyContent(content, copy);
               });
               
               elem.addEventListener("mouseenter", function(evt){
                  elem.prepend(copy);
               });
            });
            
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.addEventListener("mouseleave", function(evt){
                  document.querySelector(".copy-code").remove();
               });
            });
         });
         
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-1B44520D-4BD8-425A-A606-183CA2261E50"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /></head>
<body id="tcmecc-peripheral-library-tcmhecc">
<h1 class="title topictitle1" id="ariaid-title1">TCMECC Peripheral Library (TCMHECC)</h1><div class="body"><p class="p">The embedded Hardened Error Correction Code (HECC) Controller for TCM protects this memory region against unexpected bit change of state due to external environment conditions.</p>
<p class="p"><strong class="ph b">Configuring the library</strong></p>
<p class="p">Configure the peripheral library using the MHC.</p>
<br /><img class="image" src="GUID-C1563A42-B23C-4BDA-9805-B2953E65B7DE-low.png" alt="tcmecc_mhc_config" /><br /><ul class="ul"><li class="li"><p class="p">"Interrupt Mode" option can be enabled to add interface functions for interrupt support:</p>
<ul class="ul"><li class="li"><p class="p">Interrupts are enable during system initialization</p>
</li>
<li class="li"><p class="p"><code class="ph codeph">TCMECC_FixCallbackRegister</code> and <code class="ph codeph">TCMECC_NoFixCallbackRegister</code> functions can be used to register callbacks.</p>
</li>
</ul>
</li>
<li class="li"><p class="p">"Use injection test mode" option can be enabled to add functions for the test of error injection by reading or setting the ECC check bit value.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Using the library</strong></p>
<p class="p">If interrupts are used, the callback function should be set for expected interrupts types:</p>
<pre class="pre codeblock C"><button title="Copy Code" class="copy-code" onclick="cpy('d7796e44', this);">Copy</button><code id="d7796e44" content="    /* Register Fixable errors Callback */&#xA;    TCMECC_FixCallbackRegister(TCM_FixCallback_Function, (uintptr_t)NULL);&#xA;    /* Register UnFixable errors Callback */&#xA;    TCMECC_NoFixCallbackRegister(TCM_NoFixCallback_Function, (uintptr_t)NULL);">    /* Register Fixable errors Callback */
    TCMECC_FixCallbackRegister(TCM_FixCallback_Function, (uintptr_t)NULL);
    /* Register UnFixable errors Callback */
    TCMECC_NoFixCallbackRegister(TCM_NoFixCallback_Function, (uintptr_t)NULL);</code></pre><p class="p">When an ECC error is detected and an interrupt occurs, the fail address must be read before the status in order to avoid multiple interrupts:</p>
<pre class="pre codeblock C"><button title="Copy Code" class="copy-code" onclick="cpy('d7796e48', this);">Copy</button><code id="d7796e48" content="    /* Get DTCM fault address */&#xA;    uint32_t* fault_pointer_word = (uint32_t*)(TCMECC_GetFailAddressDTCM() &amp; 0x2003FFFF);&#xA;&#xA;    /* Get ITCM fault address */&#xA;    uint64_t* fault_pointer = (uint64_t*)(TCMECC_GetFailAddressITCM() &amp; 0x1FFFF);&#xA;&#xA;    /* Only for Fixable error handler : Read corrected data on the Fly for ITCM */&#xA;    uint64_t fault_data = *fault_pointer;&#xA;&#xA;    /* Only for Fixable error handler : Read corrected data on the Fly for DTCM */&#xA;    if ( ( (uint32_t)fault_pointer_word &gt;= 0x20000000 ) &amp;&amp; ( (uint32_t)fault_pointer_word &lt;= 0x2003FFFF ) )&#xA;    {&#xA;        fault_data_word = *fault_pointer_word;&#xA;    }&#xA;&#xA;    /* Read TCMECC Status */&#xA;    TCMECC_STATUS status_reg = TCMECC_StatusGet();">    /* Get DTCM fault address */
    uint32_t* fault_pointer_word = (uint32_t*)(TCMECC_GetFailAddressDTCM() &amp; 0x2003FFFF);

    /* Get ITCM fault address */
    uint64_t* fault_pointer = (uint64_t*)(TCMECC_GetFailAddressITCM() &amp; 0x1FFFF);

    /* Only for Fixable error handler : Read corrected data on the Fly for ITCM */
    uint64_t fault_data = *fault_pointer;

    /* Only for Fixable error handler : Read corrected data on the Fly for DTCM */
    if ( ( (uint32_t)fault_pointer_word &gt;= 0x20000000 ) &amp;&amp; ( (uint32_t)fault_pointer_word &lt;= 0x2003FFFF ) )
    {
        fault_data_word = *fault_pointer_word;
    }

    /* Read TCMECC Status */
    TCMECC_STATUS status_reg = TCMECC_StatusGet();</code></pre><p class="p">The faulty address may then be fixed by the application if applicable.</p>
<p class="p"><strong class="ph b">Error injection test mode</strong></p>
<p class="p"><strong class="ph b">ECC Check bit read</strong></p>
<p class="p">The ECC check bit value can be get when the read test mode is activated. Once this mode is activated, the check bit value for each read of data on TCM memory is stored. It is possible to get the last check bit value using the function <code class="ph codeph">TCMECC_TestModeGetCbValue</code>.</p>
<pre class="pre codeblock C"><button title="Copy Code" class="copy-code" onclick="cpy('d7796e64', this);">Copy</button><code id="d7796e64" content="    /* Reset check bit value to 0 */&#xA;    TCMECC_TestModeSetCbValue(0, 0);&#xA;    __DSB();&#xA;    __ISB();&#xA;&#xA;    /* Enable TCM ECC Test mode Read */&#xA;    TCMECC_TestModeReadEnable();&#xA;    __DSB();&#xA;    __ISB();&#xA;&#xA;    /* Read data in TCM */&#xA;    data = buffer;&#xA;&#xA;    /* Disable TCM ECC Test mode Read */&#xA;    TCMECC_TestModeReadDisable();&#xA;    __DSB();&#xA;    __ISB();&#xA;&#xA;    /* Get the Check Bit for last read data in TCM - Wait check bit values are correctly updated */&#xA;    do&#xA;    {&#xA;        TCMECC_TestModeGetCbValue(&amp;(pEccErrorInject-&gt;ecc_tcb1), &amp;(pEccErrorInject-&gt;ecc_tcb2));&#xA;    }&#xA;    while ( (pEccErrorInject-&gt;ecc_tcb1 == 0) &amp;&amp; (pEccErrorInject-&gt;ecc_tcb2 == 0) );">    /* Reset check bit value to 0 */
    TCMECC_TestModeSetCbValue(0, 0);
    __DSB();
    __ISB();

    /* Enable TCM ECC Test mode Read */
    TCMECC_TestModeReadEnable();
    __DSB();
    __ISB();

    /* Read data in TCM */
    data = buffer;

    /* Disable TCM ECC Test mode Read */
    TCMECC_TestModeReadDisable();
    __DSB();
    __ISB();

    /* Get the Check Bit for last read data in TCM - Wait check bit values are correctly updated */
    do
    {
        TCMECC_TestModeGetCbValue(&amp;(pEccErrorInject-&gt;ecc_tcb1), &amp;(pEccErrorInject-&gt;ecc_tcb2));
    }
    while ( (pEccErrorInject-&gt;ecc_tcb1 == 0) &amp;&amp; (pEccErrorInject-&gt;ecc_tcb2 == 0) );</code></pre><p class="p"><em class="ph i">Note:</em> It is recommended to use memory barriers on Cortex-M core-based products where instructions can be executed out of programmed order, or to ensure that all memory transfers or instructions are completed before any new instruction is executed. In our application, we must ensure that register modification and memory transfers are completed before executing the next step.</p>
<p class="p"><strong class="ph b">ECC Check bit write</strong></p>
<p class="p">The ECC check bit value can be override when the write test mode is activated. Once this mode is activated, the check bit value for each write of data on TCM memory is override by the given value instead of being calculated automatically. The check bit value used should be set using the function <code class="ph codeph">TCMECC_TestModeSetCbValue</code>.</p>
<pre class="pre codeblock C"><button title="Copy Code" class="copy-code" onclick="cpy('d7796e78', this);">Copy</button><code id="d7796e78" content="    /* Enable TCM ECC Test mode Write */&#xA;    TCMECC_TestModeWriteEnable();&#xA;    __DSB();&#xA;    __ISB();&#xA;&#xA;    /* Set the Check Bit for override when data will be write in TCM */&#xA;    TCMECC_TestModeSetCbValue(tcb1, tcb2);&#xA;    __DSB();&#xA;    __ISB();&#xA;&#xA;    /* Write data in TCM */&#xA;    buffer = data;&#xA;    __DSB();&#xA;    __ISB();&#xA;&#xA;    /* Disable TCM ECC Test mode Write */&#xA;    TCMECC_TestModeWriteDisable();">    /* Enable TCM ECC Test mode Write */
    TCMECC_TestModeWriteEnable();
    __DSB();
    __ISB();

    /* Set the Check Bit for override when data will be write in TCM */
    TCMECC_TestModeSetCbValue(tcb1, tcb2);
    __DSB();
    __ISB();

    /* Write data in TCM */
    buffer = data;
    __DSB();
    __ISB();

    /* Disable TCM ECC Test mode Write */
    TCMECC_TestModeWriteDisable();</code></pre><p class="p"><em class="ph i">Note:</em> It is recommended to use memory barriers on Cortex-M core-based products where instructions can be executed out of programmed order, or to ensure that all memory transfers or instructions are completed before any new instruction is executed. In our application, we must ensure that register modification and memory transfers are completed before executing the next step.</p>
</div>
<div class="related-links">
<ul class="ullinks">
<li class="link ulchildlink"><strong><a href="GUID-CEA1DA29-BE84-494A-AA97-C861E20A5956.html">TCMECC_STATUS</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-854A2B4A-D86B-46F7-B278-2D5A4F4F93D7.html">TCMECC_CALLBACK</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-E616A811-31C2-4FAB-A01E-006809BB6755.html">TCMECC_OBJ</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-E9A1537F-6ED6-4929-81DA-B31CF3D39050.html">TCMECC_Initialize</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-A25021AC-4AB9-46F3-9367-2D395A6A5130.html">TCMECC_StatusGet</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-80E0015F-EE1D-4803-9562-B78D7BEF870C.html">TCMECC_GetFailAddressITCM</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-9EC2F29D-DF15-4781-A419-29A17C8F686E.html">TCMECC_GetFailAddressDTCM</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-34C62344-B8CC-48D7-A919-C662653B9D7E.html">TCMECC_ResetCounters</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-07D91ADA-A242-428A-B4E2-C73021377345.html">TCMECC_FixCallbackRegister</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-7780D62B-24BA-411E-B999-29A97DF1B558.html">TCMECC_NoFixCallbackRegister</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-3480A3F6-7BD4-4E62-BBA1-D49774C93DFC.html">TCMECC_TestModeReadEnable</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-FEA47424-3F90-49A3-9B31-C6D5E0905078.html">TCMECC_TestModeReadDisable</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-A07AEC91-1DBF-46B6-B253-A063C5BC86C2.html">TCMECC_TestModeGetCbValue</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-B82875FD-AFB6-478F-BF52-C76B796BEC5B.html">TCMECC_TestModeWriteEnable</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-4F9448B3-1CC9-4E5B-8AB2-D9C3BB1A6460.html">TCMECC_TestModeWriteDisable</a></strong><br />
</li>
<li class="link ulchildlink"><strong><a href="GUID-99905C10-3C9C-41F4-8691-6018AF48AC64.html">TCMECC_TestModeSetCbValue</a></strong><br />
</li>
</ul>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-1CE8F33B-F9EF-4806-9B9A-83D4F0D0F22C.html">SAM RH71 Aerospace Libraries</a></div>
</div>
</div></body>
</html>