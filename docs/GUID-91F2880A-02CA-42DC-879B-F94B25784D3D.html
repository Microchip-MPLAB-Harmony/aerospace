<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="ICM Peripheral Library (ICM)" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="icm-peripheral-library-icm" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<title>ICM Peripheral Library (ICM)</title>
<meta name="Microsoft.Help.Id" content="GUID-1496A2CC-C97C-4626-8C96-AF36CD92FAF6-icm-peripheral-library-icm" />
<meta name="Microsoft.Help.TocParent" content="GUID-1496A2CC-C97C-4626-8C96-AF36CD92FAF6" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Aerospace Library Reference A 01/2022" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
         
         function copyContent(content, button) {
         
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                     button.textContent = "Copy";
                     button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
               console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
         }
         
         function cpy(id, button) {
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            
            copyContent(content, button);
         }
         
         document.addEventListener("DOMContentLoaded", function(event) {
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.style.position = "relative";
               var copy = document.createElement("button");
               copy.textContent = "Copy";
               copy.setAttribute("class", "copy-code");
               
               var content = elem.textContent;
               
               copy.addEventListener("click", function(){
                  copyContent(content, copy);
               });
               
               elem.addEventListener("mouseenter", function(evt){
                  elem.prepend(copy);
               });
            });
            
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.addEventListener("mouseleave", function(evt){
                  document.querySelector(".copy-code").remove();
               });
            });
         });
         
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-91F2880A-02CA-42DC-879B-F94B25784D3D"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /></head>
<body id="icm-peripheral-library-icm">
<h1 class="title topictitle1" id="ariaid-title1">ICM Peripheral Library (ICM)</h1><div class="body"><p class="p">The Integrity Check Monitor (ICM) is a DMA controller that performs hash calculation over multiple memory regions using transfer descriptors located in memory (ICM Descriptor Area). The Hash function is based on the Secure Hash Algorithm (SHA). The ICM integrates two modes of operation. The first one is used to hash a list of memory regions and save the digests to memory (ICM Hash Area). The second mode is an active monitoring of the memory. In that mode, the hash function is evaluated and compared to the digest located at a predefined memory
address (ICM Hash Area). If a mismatch occurs, an interrupt is raised.</p>
<p class="p"><strong class="ph b">Configuring the library</strong></p>
<p class="p">Configure the peripheral library using the MHC.</p>
<p class="p">The MHC can be used to configure the 4 memory regions (without secondary list).</p>
<br /><img class="image" src="GUID-95D16797-A678-4089-96AD-60BEF4B0A90D-low.png" alt="icm_mhc_config" /><br /><ul class="ul"><li class="li"><p class="p">"Interrupt Mode" option can be enabled to add interface functions for interrupt support:</p>
<ul class="ul"><li class="li"><p class="p">Interrupts are enable during system initialization</p>
</li>
<li class="li"><p class="p"><code class="ph codeph">ICM_CallbackRegister</code> function can be use to register a callback.</p>
</li>
</ul>
</li>
<li class="li"><p class="p">"Enable dual input buffer" : If check, set DUALBUFF bit in configuration register. (Higher bandwidth required on system bus)</p>
</li>
<li class="li"><p class="p">"Automatic switch to compare digest": If check, set ASCD bit in configuration register. (The ICM passes through the Main List once to calculate the message digest of the monitored area. When WRAP = 1 in ICM_RCFG, the ICM begins monitoring).</p>
</li>
<li class="li"><p class="p">"Bus Burden Control" : If check, set BBC value in configuration register. (The number of system clock cycles between the end of the current processing and the next block transfer is set to 2 exponent BBC . Up to 32,768 cycles can be inserted).</p>
</li>
<li class="li"><p class="p">"Disable Secondary List Branching" : If check, set SLBDIS bit in configuration register (Branching to the Secondary List is forbidden).</p>
</li>
<li class="li"><p class="p">"Disable End of Monitoring" : If check, set EOMDIS bit in configuration register (End of Monitoring is forbidden).</p>
</li>
<li class="li"><p class="p">"Disable Write Back" : If check, set WBDIS bit in configuration register (Write Back operations are forbidden, ICM_RCFG.CDWBN has no effect).</p>
</li>
</ul>
<br /><img class="image" src="GUID-D22D0FCA-E31E-4EAE-A755-91737E4AEC6E-low.png" alt="icm_mhc_config_region" /><br /><ul class="ul"><li class="li"><p class="p">"Number of Region Descriptor" : Number of regions to configure</p>
</li>
<li class="li"><p class="p">"Start Address" : The start address of the region.</p>
</li>
<li class="li"><p class="p">"SHA Algorithm" : The used algorithm to compute hash for this region</p>
</li>
<li class="li"><p class="p">"SHA Processing Delay" : When SHA1 algorithm is processed, the runtime period is either 85 or 209 clock cycles. When SHA256 or SHA224 algorithm is processed, the runtime period is either 72 or 194 clock cycles.</p>
</li>
<li class="li"><p class="p">"Disable interrupt events" : Check the events to disable the corresponding interrupt for this region (enabled by default)</p>
</li>
<li class="li"><p class="p">"Enable End of Monitoring" : The current region descriptor will terminates the Main List. WRAP value has no effect.</p>
</li>
<li class="li"><p class="p">"Wrap command" : The next region descriptor address loaded is ICM_DSCR register value.</p>
</li>
<li class="li"><p class="p">"Digest process" : If checked, the digest value is compared to the digest stored in the Hash area. Otherwise, the digest is written to the Hash area.</p>
</li>
<li class="li"><p class="p">"Size in byte" : Region data size. Should be a multiple of 64.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Using the library</strong></p>
<p class="p">After system initialization and before enabling the ICM, the memory hash address area should be set using the function  <code class="ph codeph">ICM_SetHashStartAddress</code>. This address should be a multiple of 128 bytes. For each region, 32 bytes are used to store the computed hash:</p>
<pre class="pre codeblock c">    <em class="hl-comment">/* Hash Buffer were ICM will store the computed hash for each region */</em>
    uint32_t <span class="hl-functions">__attribute__</span>((aligned (<span class="hl-number">128</span>))) bufferHash[<span class="hl-number">4</span>][<span class="hl-number">8</span>] = {<span class="hl-number">0</span>};

    <em class="hl-comment">/* Set ICM memory address for generated hash */</em>
    ICM_SetHashStartAddress((uint32_t) &amp; bufferHash);</pre><p class="p">If interrupts are used, the callback function should be set and expected interrupts enabled:</p>
<pre class="pre codeblock c">    <em class="hl-comment">/* Register ICM Callback */</em>
    ICM_CallbackRegister(ICM_Callback_Function, (uintptr_t)NULL);

    <em class="hl-comment">/* Enable Interrupts */</em>
    ICM_InterruptEnable(ICM_INT_MSK_HASH_R0_MASK | ICM_INT_MSK_HASH_R1_MASK |
                        ICM_INT_MSK_HASH_R2_MASK | ICM_INT_MSK_HASH_R3_MASK);</pre><p class="p">In order to run only one hash of the region, the ICM can be start using <code class="ph codeph">ICM_Enable</code> function:</p>
<pre class="pre codeblock c">    <em class="hl-comment">/* Enable ICM to perform hash of regions */</em>
    ICM_Enable();</pre><p class="p">To modify the ICM configuration, it should be disabled using the <code class="ph codeph">ICM_Disable</code> function:</p>
<pre class="pre codeblock c">    <em class="hl-comment">/* Disable ICM */</em>
    ICM_Disable();
    <em class="hl-comment">/* Wait end of current memory region monitored */</em>
    <strong class="hl-keyword">while</strong> ( (ICM_StatusGet() &amp; ICM_STATUS_ENABLE) == ICM_STATUS_ENABLE );</pre><p class="p">If a first hash has already been performed, the ICM can be run in monitoring mode after disabling the write back feature:</p>
<pre class="pre codeblock c">    <em class="hl-comment">/* Disable ICM Write back feature */</em>
    ICM_WriteBackDisable(true);

    <em class="hl-comment">/* Enable ICM monitor mode */</em>
    ICM_MonitorEnable(ICM_REGION0_MASK | ICM_REGION1_MASK | ICM_REGION2_MASK | ICM_REGION3_MASK);

    <em class="hl-comment">/* Enable mismatch interrupts */</em>
    ICM_InterruptEnable(ICM_INT_MSK_DIGEST_MISMATCH_R0_MASK |
                        ICM_INT_MSK_DIGEST_MISMATCH_R1_MASK |
                        ICM_INT_MSK_DIGEST_MISMATCH_R2_MASK |
                        ICM_INT_MSK_DIGEST_MISMATCH_R3_MASK);
    <em class="hl-comment">/* Enable ICM */</em>
    ICM_Enable();</pre></div>
</body>
</html>